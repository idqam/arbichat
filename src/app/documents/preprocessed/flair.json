{
  "document": "flair",
  "chunks": [
    {
      "id": "flair.mdx_chunk_0",
      "content": "***\n\ntitle: 'Quickstart: Indexing Arbitrum custom data via Flair'\ndescription: 'Real-time and historical custom data indexing for any evm chain.'\nauthor: kasra-khosravi\nsme: kasra-khosravi\nthird\\_party\\_content\\_owner: kasrakhosravi\nsidebar\\_label: 'Flair'\n-----------------------\n\n[Flair](https://flair.dev), Real-time and historical custom data indexing for any evm chain. Flair offers reusable **indexing primitives** (such as fault-tolerant RPC ingestors, custom processors, re-org aware database integrations) to make it easy to receive, transform, store and access your on-chain data. [![flair architecture](https://imgur.com/0q5bHZK.png)](https://docs.flair.dev/)\n\n## Why Flair? Compared to other alternatives the main reasons are:\n\n* üöÄ Adopting **parallel and distributed processing** paradigm means high scalability and resiliency for your indexing stack. Instead of constrained sequential processing (e.g Subgraph). * üß© Focused on **primitives**, which means on the left you plug-in an RPC and on the right you output the data to any destination database."
    },
    {
      "id": "flair.mdx_chunk_1",
      "content": "* üöÑ Native **real-time stream processing** for certain data workload (such as aggregations, rollups) for things like total volume per pool, or total portfolio per user wallet. * ‚òÅÔ∏è **Managed** cloud services avoid DevOps and irrelevant engineering costs for dApp developers. * üßë‚Äçüíª Avoid decentralization **overhead** (consensus, network hops, etc) since we believe to enable best UX for dApps reading data must be as close to the developers as possible. ### Features\n\n* ‚úÖ Listen to **any EVM chain** with just an RPC URL. * Free managed RPC URLs for +8 popular chains already included. * Works with both websocket and https-only RPCs. * ‚úÖ Track and ingest **any contract** for **any event topic.**\n  * Auto-track new contracts deployed from factory contracts. * ‚úÖ **Custom processor scripts** with Javascript runtime (with **Typescript** support)\n  * Make external API or Webhook calls to third-party or your backend. * Get current or historical USD value of any ERC20 token amount of any contract address on any chain. * Use any external NPM library. * ‚úÖ **Stream** any stored data to your destination database (Postgres, MongoDB, MySQL, Kafka, Elasticsearch, Timescale, etc)."
    },
    {
      "id": "flair.mdx_chunk_2",
      "content": "## Getting Started\n\n1Ô∏è‚É£ Clone the [starter boilerplate](https://github.com/flair-sdk/starter-boilerplate) template and follow the instructions\n\n```bash\ngit clone https://github.com/flair-sdk/starter-boilerplate.git\n# ... follow instructions in README.md\n```\n\n:::info\n\nBoilerplate instructions will create a **new cluster**, generate **an API Key**, and set up a manifest.yml to index your **first contract** with **sample custom processor** scripts. Learn more about the [structure of manifest.yml](https://docs.flair.dev/reference/manifest.yml). :::\n\n2Ô∏è‚É£ Configure Arbitrum RPC nodes\n\nSet a unique namespace, Arbitrum chainId and RPC endpoint in your config. Remember that you can add up to 10 RPC endpoints for resiliency."
    },
    {
      "id": "flair.mdx_chunk_3",
      "content": "```yaml\n{\n  'cluster': 'dev',\n  'namespace': 'my-awesome-arbitrum-indexing-dev',\n  'indexers':\n    [\n      {\n        'chainId': 42161,\n        'enabled': true,\n        'ingestionFilterGroup': 'default',\n        'processingFilterGroup': 'default',\n        'sources': [\n            # Highly-recommended to have at least 1 websocket endpoint\n            'wss://arbitrum-one.publicnode.com',\n            # You can put multiple endpoints for failover\n            'https://arbitrum.llamarpc.com',\n          ],\n      },\n    ],\n}\n```\n\n3Ô∏è‚É£ Sync some historical data using [backfill command](https://docs.flair.dev/reference/backfilling). Remember that `enabled: true` flag in your `config` enabled your indexer to capture data in real-time already."
    },
    {
      "id": "flair.mdx_chunk_4",
      "content": "```bash\n# backfill certain contracts or block ranges\npnpm flair backfill --chain 42161 --address\n0x22dc069183f85a8473553e32b59efc9fec506baf -d backward --max-blocks 10000\n# backfill for a specific block number, if you have certain events you wanna test with\npnpm flair backfill --chain 42161 -b 132763420\n# backfill for the recent data in the last X minute\npnpm flair backfill --chain 42161 --min-timestamp=\"30 mins ago\" -d backward\n```\n\n4Ô∏è‚É£ [Query](https://docs.flair.dev/#getting-started) your custom indexed data. 5Ô∏è‚É£ Stream the data to your [own database](https://docs.flair.dev/reference/database#your-own-database). ## Examples\n\nExplore real-world usage of Flair indexing primitives for various use-cases."
    },
    {
      "id": "flair.mdx_chunk_5",
      "content": "### DeFi\n\n* [Aggregate protocol fees in USD across multiple chains](https://github.com/flair-sdk/examples/tree/main/aggregate-protocol-fees-in-usd)\n* [Calculate \"Health Factor\" of positions with contract factory tracking](https://github.com/flair-sdk/examples/tree/main/health-factor-with-factory-tracking)\n* [Index Uniswap v2 swaps with USD price for all addresses](https://github.com/flair-sdk/examples/tree/main/uniswap-v2-events-from-all-contracts-with-usd-price)\n\n### NFT\n\n* [Index ERC721 and ERC1155 NFTs on any EVM chain with an RPC URL](https://github.com/flair-sdk/examples/tree/main/erc721-and-erc1155-nft-indexing)\n\n## Need help? [Our engineers](https://docs.flair.dev/talk-to-an-engineer) are available to help you at any stage."
    }
  ]
}